// Generated by jextract

package com.microsoft.win32;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct IOleLinkVtbl {
 *     HRESULT (*QueryInterface)(IOleLink*,const IID*,void**);
 *     ULONG (*AddRef)(IOleLink*);
 *     ULONG (*Release)(IOleLink*);
 *     HRESULT (*SetUpdateOptions)(IOleLink*,DWORD);
 *     HRESULT (*GetUpdateOptions)(IOleLink*,DWORD*);
 *     HRESULT (*SetSourceMoniker)(IOleLink*,IMoniker*,const IID*);
 *     HRESULT (*GetSourceMoniker)(IOleLink*,IMoniker**);
 *     HRESULT (*SetSourceDisplayName)(IOleLink*,LPCOLESTR);
 *     HRESULT (*GetSourceDisplayName)(IOleLink*,LPOLESTR*);
 *     HRESULT (*BindToSource)(IOleLink*,DWORD,IBindCtx*);
 *     HRESULT (*BindIfRunning)(IOleLink*);
 *     HRESULT (*GetBoundSource)(IOleLink*,IUnknown**);
 *     HRESULT (*UnbindSource)(IOleLink*);
 *     HRESULT (*Update)(IOleLink*,IBindCtx*);
 * };
 * }
 */
public class IOleLinkVtbl {

    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("SetUpdateOptions"),
        Constants$root.C_POINTER$LAYOUT.withName("GetUpdateOptions"),
        Constants$root.C_POINTER$LAYOUT.withName("SetSourceMoniker"),
        Constants$root.C_POINTER$LAYOUT.withName("GetSourceMoniker"),
        Constants$root.C_POINTER$LAYOUT.withName("SetSourceDisplayName"),
        Constants$root.C_POINTER$LAYOUT.withName("GetSourceDisplayName"),
        Constants$root.C_POINTER$LAYOUT.withName("BindToSource"),
        Constants$root.C_POINTER$LAYOUT.withName("BindIfRunning"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBoundSource"),
        Constants$root.C_POINTER$LAYOUT.withName("UnbindSource"),
        Constants$root.C_POINTER$LAYOUT.withName("Update")
    ).withName("IOleLinkVtbl");
    public static MemoryLayout $LAYOUT() {
        return IOleLinkVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor QueryInterface_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface_UP$MH = RuntimeHelper.upcallHandle(QueryInterface.class, "apply", IOleLinkVtbl.QueryInterface_UP$FUNC);
    static final FunctionDescriptor QueryInterface_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.QueryInterface_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*QueryInterface)(IOleLink*,const IID*,void**);
     * }
     */
    public interface QueryInterface {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(QueryInterface fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.QueryInterface_UP$MH, fi, IOleLinkVtbl.QueryInterface$FUNC, scope);
        }
        static QueryInterface ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleLinkVtbl.QueryInterface_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IOleLinkVtbl.QueryInterface$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*QueryInterface)(IOleLink*,const IID*,void**);
     * }
     */
    public static MemorySegment QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.QueryInterface$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*QueryInterface)(IOleLink*,const IID*,void**);
     * }
     */
    public static void QueryInterface$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemorySegment QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface(MemorySegment segment, SegmentScope scope) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), scope);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor AddRef_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef_UP$MH = RuntimeHelper.upcallHandle(AddRef.class, "apply", IOleLinkVtbl.AddRef_UP$FUNC);
    static final FunctionDescriptor AddRef_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.AddRef_DOWN$FUNC
    );
    /**
     * {@snippet :
 * ULONG (*AddRef)(IOleLink*);
     * }
     */
    public interface AddRef {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(AddRef fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.AddRef_UP$MH, fi, IOleLinkVtbl.AddRef$FUNC, scope);
        }
        static AddRef ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleLinkVtbl.AddRef_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IOleLinkVtbl.AddRef$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ULONG (*AddRef)(IOleLink*);
     * }
     */
    public static MemorySegment AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.AddRef$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ULONG (*AddRef)(IOleLink*);
     * }
     */
    public static void AddRef$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.AddRef$VH.set(seg, x);
    }
    public static MemorySegment AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef(MemorySegment segment, SegmentScope scope) {
        return AddRef.ofAddress(AddRef$get(segment), scope);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor Release_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release_UP$MH = RuntimeHelper.upcallHandle(Release.class, "apply", IOleLinkVtbl.Release_UP$FUNC);
    static final FunctionDescriptor Release_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.Release_DOWN$FUNC
    );
    /**
     * {@snippet :
 * ULONG (*Release)(IOleLink*);
     * }
     */
    public interface Release {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(Release fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.Release_UP$MH, fi, IOleLinkVtbl.Release$FUNC, scope);
        }
        static Release ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleLinkVtbl.Release_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IOleLinkVtbl.Release$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ULONG (*Release)(IOleLink*);
     * }
     */
    public static MemorySegment Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.Release$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ULONG (*Release)(IOleLink*);
     * }
     */
    public static void Release$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.Release$VH.set(seg, x);
    }
    public static MemorySegment Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release(MemorySegment segment, SegmentScope scope) {
        return Release.ofAddress(Release$get(segment), scope);
    }
    static final FunctionDescriptor SetUpdateOptions$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final FunctionDescriptor SetUpdateOptions_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle SetUpdateOptions_UP$MH = RuntimeHelper.upcallHandle(SetUpdateOptions.class, "apply", IOleLinkVtbl.SetUpdateOptions_UP$FUNC);
    static final FunctionDescriptor SetUpdateOptions_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle SetUpdateOptions_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.SetUpdateOptions_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetUpdateOptions)(IOleLink*,DWORD);
     * }
     */
    public interface SetUpdateOptions {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(SetUpdateOptions fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.SetUpdateOptions_UP$MH, fi, IOleLinkVtbl.SetUpdateOptions$FUNC, scope);
        }
        static SetUpdateOptions ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)IOleLinkVtbl.SetUpdateOptions_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetUpdateOptions$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetUpdateOptions"));
    public static VarHandle SetUpdateOptions$VH() {
        return IOleLinkVtbl.SetUpdateOptions$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetUpdateOptions)(IOleLink*,DWORD);
     * }
     */
    public static MemorySegment SetUpdateOptions$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.SetUpdateOptions$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetUpdateOptions)(IOleLink*,DWORD);
     * }
     */
    public static void SetUpdateOptions$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.SetUpdateOptions$VH.set(seg, x);
    }
    public static MemorySegment SetUpdateOptions$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.SetUpdateOptions$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetUpdateOptions$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.SetUpdateOptions$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetUpdateOptions SetUpdateOptions(MemorySegment segment, SegmentScope scope) {
        return SetUpdateOptions.ofAddress(SetUpdateOptions$get(segment), scope);
    }
    static final FunctionDescriptor GetUpdateOptions$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetUpdateOptions_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUpdateOptions_UP$MH = RuntimeHelper.upcallHandle(GetUpdateOptions.class, "apply", IOleLinkVtbl.GetUpdateOptions_UP$FUNC);
    static final FunctionDescriptor GetUpdateOptions_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUpdateOptions_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.GetUpdateOptions_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetUpdateOptions)(IOleLink*,DWORD*);
     * }
     */
    public interface GetUpdateOptions {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetUpdateOptions fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.GetUpdateOptions_UP$MH, fi, IOleLinkVtbl.GetUpdateOptions$FUNC, scope);
        }
        static GetUpdateOptions ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleLinkVtbl.GetUpdateOptions_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUpdateOptions$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetUpdateOptions"));
    public static VarHandle GetUpdateOptions$VH() {
        return IOleLinkVtbl.GetUpdateOptions$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetUpdateOptions)(IOleLink*,DWORD*);
     * }
     */
    public static MemorySegment GetUpdateOptions$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetUpdateOptions$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetUpdateOptions)(IOleLink*,DWORD*);
     * }
     */
    public static void GetUpdateOptions$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.GetUpdateOptions$VH.set(seg, x);
    }
    public static MemorySegment GetUpdateOptions$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetUpdateOptions$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUpdateOptions$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.GetUpdateOptions$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUpdateOptions GetUpdateOptions(MemorySegment segment, SegmentScope scope) {
        return GetUpdateOptions.ofAddress(GetUpdateOptions$get(segment), scope);
    }
    static final FunctionDescriptor SetSourceMoniker$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetSourceMoniker_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetSourceMoniker_UP$MH = RuntimeHelper.upcallHandle(SetSourceMoniker.class, "apply", IOleLinkVtbl.SetSourceMoniker_UP$FUNC);
    static final FunctionDescriptor SetSourceMoniker_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetSourceMoniker_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.SetSourceMoniker_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetSourceMoniker)(IOleLink*,IMoniker*,const IID*);
     * }
     */
    public interface SetSourceMoniker {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(SetSourceMoniker fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.SetSourceMoniker_UP$MH, fi, IOleLinkVtbl.SetSourceMoniker$FUNC, scope);
        }
        static SetSourceMoniker ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleLinkVtbl.SetSourceMoniker_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetSourceMoniker$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetSourceMoniker"));
    public static VarHandle SetSourceMoniker$VH() {
        return IOleLinkVtbl.SetSourceMoniker$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetSourceMoniker)(IOleLink*,IMoniker*,const IID*);
     * }
     */
    public static MemorySegment SetSourceMoniker$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.SetSourceMoniker$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetSourceMoniker)(IOleLink*,IMoniker*,const IID*);
     * }
     */
    public static void SetSourceMoniker$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.SetSourceMoniker$VH.set(seg, x);
    }
    public static MemorySegment SetSourceMoniker$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.SetSourceMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetSourceMoniker$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.SetSourceMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetSourceMoniker SetSourceMoniker(MemorySegment segment, SegmentScope scope) {
        return SetSourceMoniker.ofAddress(SetSourceMoniker$get(segment), scope);
    }
    static final FunctionDescriptor GetSourceMoniker$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetSourceMoniker_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSourceMoniker_UP$MH = RuntimeHelper.upcallHandle(GetSourceMoniker.class, "apply", IOleLinkVtbl.GetSourceMoniker_UP$FUNC);
    static final FunctionDescriptor GetSourceMoniker_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSourceMoniker_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.GetSourceMoniker_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetSourceMoniker)(IOleLink*,IMoniker**);
     * }
     */
    public interface GetSourceMoniker {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetSourceMoniker fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.GetSourceMoniker_UP$MH, fi, IOleLinkVtbl.GetSourceMoniker$FUNC, scope);
        }
        static GetSourceMoniker ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleLinkVtbl.GetSourceMoniker_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSourceMoniker$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetSourceMoniker"));
    public static VarHandle GetSourceMoniker$VH() {
        return IOleLinkVtbl.GetSourceMoniker$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetSourceMoniker)(IOleLink*,IMoniker**);
     * }
     */
    public static MemorySegment GetSourceMoniker$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetSourceMoniker$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetSourceMoniker)(IOleLink*,IMoniker**);
     * }
     */
    public static void GetSourceMoniker$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.GetSourceMoniker$VH.set(seg, x);
    }
    public static MemorySegment GetSourceMoniker$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetSourceMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSourceMoniker$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.GetSourceMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSourceMoniker GetSourceMoniker(MemorySegment segment, SegmentScope scope) {
        return GetSourceMoniker.ofAddress(GetSourceMoniker$get(segment), scope);
    }
    static final FunctionDescriptor SetSourceDisplayName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetSourceDisplayName_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetSourceDisplayName_UP$MH = RuntimeHelper.upcallHandle(SetSourceDisplayName.class, "apply", IOleLinkVtbl.SetSourceDisplayName_UP$FUNC);
    static final FunctionDescriptor SetSourceDisplayName_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetSourceDisplayName_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.SetSourceDisplayName_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetSourceDisplayName)(IOleLink*,LPCOLESTR);
     * }
     */
    public interface SetSourceDisplayName {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(SetSourceDisplayName fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.SetSourceDisplayName_UP$MH, fi, IOleLinkVtbl.SetSourceDisplayName$FUNC, scope);
        }
        static SetSourceDisplayName ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleLinkVtbl.SetSourceDisplayName_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetSourceDisplayName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetSourceDisplayName"));
    public static VarHandle SetSourceDisplayName$VH() {
        return IOleLinkVtbl.SetSourceDisplayName$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetSourceDisplayName)(IOleLink*,LPCOLESTR);
     * }
     */
    public static MemorySegment SetSourceDisplayName$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.SetSourceDisplayName$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetSourceDisplayName)(IOleLink*,LPCOLESTR);
     * }
     */
    public static void SetSourceDisplayName$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.SetSourceDisplayName$VH.set(seg, x);
    }
    public static MemorySegment SetSourceDisplayName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.SetSourceDisplayName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetSourceDisplayName$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.SetSourceDisplayName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetSourceDisplayName SetSourceDisplayName(MemorySegment segment, SegmentScope scope) {
        return SetSourceDisplayName.ofAddress(SetSourceDisplayName$get(segment), scope);
    }
    static final FunctionDescriptor GetSourceDisplayName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetSourceDisplayName_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSourceDisplayName_UP$MH = RuntimeHelper.upcallHandle(GetSourceDisplayName.class, "apply", IOleLinkVtbl.GetSourceDisplayName_UP$FUNC);
    static final FunctionDescriptor GetSourceDisplayName_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSourceDisplayName_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.GetSourceDisplayName_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetSourceDisplayName)(IOleLink*,LPOLESTR*);
     * }
     */
    public interface GetSourceDisplayName {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetSourceDisplayName fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.GetSourceDisplayName_UP$MH, fi, IOleLinkVtbl.GetSourceDisplayName$FUNC, scope);
        }
        static GetSourceDisplayName ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleLinkVtbl.GetSourceDisplayName_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSourceDisplayName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetSourceDisplayName"));
    public static VarHandle GetSourceDisplayName$VH() {
        return IOleLinkVtbl.GetSourceDisplayName$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetSourceDisplayName)(IOleLink*,LPOLESTR*);
     * }
     */
    public static MemorySegment GetSourceDisplayName$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetSourceDisplayName$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetSourceDisplayName)(IOleLink*,LPOLESTR*);
     * }
     */
    public static void GetSourceDisplayName$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.GetSourceDisplayName$VH.set(seg, x);
    }
    public static MemorySegment GetSourceDisplayName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetSourceDisplayName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSourceDisplayName$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.GetSourceDisplayName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSourceDisplayName GetSourceDisplayName(MemorySegment segment, SegmentScope scope) {
        return GetSourceDisplayName.ofAddress(GetSourceDisplayName$get(segment), scope);
    }
    static final FunctionDescriptor BindToSource$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor BindToSource_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle BindToSource_UP$MH = RuntimeHelper.upcallHandle(BindToSource.class, "apply", IOleLinkVtbl.BindToSource_UP$FUNC);
    static final FunctionDescriptor BindToSource_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle BindToSource_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.BindToSource_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*BindToSource)(IOleLink*,DWORD,IBindCtx*);
     * }
     */
    public interface BindToSource {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(BindToSource fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.BindToSource_UP$MH, fi, IOleLinkVtbl.BindToSource$FUNC, scope);
        }
        static BindToSource ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleLinkVtbl.BindToSource_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle BindToSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("BindToSource"));
    public static VarHandle BindToSource$VH() {
        return IOleLinkVtbl.BindToSource$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*BindToSource)(IOleLink*,DWORD,IBindCtx*);
     * }
     */
    public static MemorySegment BindToSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.BindToSource$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*BindToSource)(IOleLink*,DWORD,IBindCtx*);
     * }
     */
    public static void BindToSource$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.BindToSource$VH.set(seg, x);
    }
    public static MemorySegment BindToSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.BindToSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void BindToSource$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.BindToSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static BindToSource BindToSource(MemorySegment segment, SegmentScope scope) {
        return BindToSource.ofAddress(BindToSource$get(segment), scope);
    }
    static final FunctionDescriptor BindIfRunning$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor BindIfRunning_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle BindIfRunning_UP$MH = RuntimeHelper.upcallHandle(BindIfRunning.class, "apply", IOleLinkVtbl.BindIfRunning_UP$FUNC);
    static final FunctionDescriptor BindIfRunning_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle BindIfRunning_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.BindIfRunning_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*BindIfRunning)(IOleLink*);
     * }
     */
    public interface BindIfRunning {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(BindIfRunning fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.BindIfRunning_UP$MH, fi, IOleLinkVtbl.BindIfRunning$FUNC, scope);
        }
        static BindIfRunning ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleLinkVtbl.BindIfRunning_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle BindIfRunning$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("BindIfRunning"));
    public static VarHandle BindIfRunning$VH() {
        return IOleLinkVtbl.BindIfRunning$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*BindIfRunning)(IOleLink*);
     * }
     */
    public static MemorySegment BindIfRunning$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.BindIfRunning$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*BindIfRunning)(IOleLink*);
     * }
     */
    public static void BindIfRunning$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.BindIfRunning$VH.set(seg, x);
    }
    public static MemorySegment BindIfRunning$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.BindIfRunning$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void BindIfRunning$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.BindIfRunning$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static BindIfRunning BindIfRunning(MemorySegment segment, SegmentScope scope) {
        return BindIfRunning.ofAddress(BindIfRunning$get(segment), scope);
    }
    static final FunctionDescriptor GetBoundSource$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetBoundSource_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBoundSource_UP$MH = RuntimeHelper.upcallHandle(GetBoundSource.class, "apply", IOleLinkVtbl.GetBoundSource_UP$FUNC);
    static final FunctionDescriptor GetBoundSource_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBoundSource_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.GetBoundSource_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetBoundSource)(IOleLink*,IUnknown**);
     * }
     */
    public interface GetBoundSource {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetBoundSource fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.GetBoundSource_UP$MH, fi, IOleLinkVtbl.GetBoundSource$FUNC, scope);
        }
        static GetBoundSource ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleLinkVtbl.GetBoundSource_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBoundSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBoundSource"));
    public static VarHandle GetBoundSource$VH() {
        return IOleLinkVtbl.GetBoundSource$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetBoundSource)(IOleLink*,IUnknown**);
     * }
     */
    public static MemorySegment GetBoundSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetBoundSource$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetBoundSource)(IOleLink*,IUnknown**);
     * }
     */
    public static void GetBoundSource$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.GetBoundSource$VH.set(seg, x);
    }
    public static MemorySegment GetBoundSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.GetBoundSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBoundSource$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.GetBoundSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBoundSource GetBoundSource(MemorySegment segment, SegmentScope scope) {
        return GetBoundSource.ofAddress(GetBoundSource$get(segment), scope);
    }
    static final FunctionDescriptor UnbindSource$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor UnbindSource_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle UnbindSource_UP$MH = RuntimeHelper.upcallHandle(UnbindSource.class, "apply", IOleLinkVtbl.UnbindSource_UP$FUNC);
    static final FunctionDescriptor UnbindSource_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle UnbindSource_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.UnbindSource_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*UnbindSource)(IOleLink*);
     * }
     */
    public interface UnbindSource {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(UnbindSource fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.UnbindSource_UP$MH, fi, IOleLinkVtbl.UnbindSource$FUNC, scope);
        }
        static UnbindSource ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleLinkVtbl.UnbindSource_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle UnbindSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("UnbindSource"));
    public static VarHandle UnbindSource$VH() {
        return IOleLinkVtbl.UnbindSource$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*UnbindSource)(IOleLink*);
     * }
     */
    public static MemorySegment UnbindSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.UnbindSource$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*UnbindSource)(IOleLink*);
     * }
     */
    public static void UnbindSource$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.UnbindSource$VH.set(seg, x);
    }
    public static MemorySegment UnbindSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.UnbindSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void UnbindSource$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.UnbindSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static UnbindSource UnbindSource(MemorySegment segment, SegmentScope scope) {
        return UnbindSource.ofAddress(UnbindSource$get(segment), scope);
    }
    static final FunctionDescriptor Update$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor Update_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Update_UP$MH = RuntimeHelper.upcallHandle(Update.class, "apply", IOleLinkVtbl.Update_UP$FUNC);
    static final FunctionDescriptor Update_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Update_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleLinkVtbl.Update_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*Update)(IOleLink*,IBindCtx*);
     * }
     */
    public interface Update {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(Update fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleLinkVtbl.Update_UP$MH, fi, IOleLinkVtbl.Update$FUNC, scope);
        }
        static Update ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleLinkVtbl.Update_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Update$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Update"));
    public static VarHandle Update$VH() {
        return IOleLinkVtbl.Update$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*Update)(IOleLink*,IBindCtx*);
     * }
     */
    public static MemorySegment Update$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.Update$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*Update)(IOleLink*,IBindCtx*);
     * }
     */
    public static void Update$set(MemorySegment seg, MemorySegment x) {
        IOleLinkVtbl.Update$VH.set(seg, x);
    }
    public static MemorySegment Update$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleLinkVtbl.Update$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Update$set(MemorySegment seg, long index, MemorySegment x) {
        IOleLinkVtbl.Update$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Update Update(MemorySegment segment, SegmentScope scope) {
        return Update.ofAddress(Update$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


