// Generated by jextract

package com.microsoft.win32;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct IRecordInfoVtbl {
 *     HRESULT (*QueryInterface)(IRecordInfo*,const IID*,void**);
 *     ULONG (*AddRef)(IRecordInfo*);
 *     ULONG (*Release)(IRecordInfo*);
 *     HRESULT (*RecordInit)(IRecordInfo*,PVOID);
 *     HRESULT (*RecordClear)(IRecordInfo*,PVOID);
 *     HRESULT (*RecordCopy)(IRecordInfo*,PVOID,PVOID);
 *     HRESULT (*GetGuid)(IRecordInfo*,GUID*);
 *     HRESULT (*GetName)(IRecordInfo*,BSTR*);
 *     HRESULT (*GetSize)(IRecordInfo*,ULONG*);
 *     HRESULT (*GetTypeInfo)(IRecordInfo*,ITypeInfo**);
 *     HRESULT (*GetField)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*);
 *     HRESULT (*GetFieldNoCopy)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*,PVOID*);
 *     HRESULT (*PutField)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
 *     HRESULT (*PutFieldNoCopy)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
 *     HRESULT (*GetFieldNames)(IRecordInfo*,ULONG*,BSTR*);
 *     BOOL (*IsMatchingType)(IRecordInfo*,IRecordInfo*);
 *     PVOID (*RecordCreate)(IRecordInfo*);
 *     HRESULT (*RecordCreateCopy)(IRecordInfo*,PVOID,PVOID*);
 *     HRESULT (*RecordDestroy)(IRecordInfo*,PVOID);
 * };
 * }
 */
public class IRecordInfoVtbl {

    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordInit"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordClear"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetGuid"),
        Constants$root.C_POINTER$LAYOUT.withName("GetName"),
        Constants$root.C_POINTER$LAYOUT.withName("GetSize"),
        Constants$root.C_POINTER$LAYOUT.withName("GetTypeInfo"),
        Constants$root.C_POINTER$LAYOUT.withName("GetField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFieldNoCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("PutField"),
        Constants$root.C_POINTER$LAYOUT.withName("PutFieldNoCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFieldNames"),
        Constants$root.C_POINTER$LAYOUT.withName("IsMatchingType"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordCreate"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordCreateCopy"),
        Constants$root.C_POINTER$LAYOUT.withName("RecordDestroy")
    ).withName("IRecordInfoVtbl");
    public static MemoryLayout $LAYOUT() {
        return IRecordInfoVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor QueryInterface_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface_UP$MH = RuntimeHelper.upcallHandle(QueryInterface.class, "apply", IRecordInfoVtbl.QueryInterface_UP$FUNC);
    static final FunctionDescriptor QueryInterface_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.QueryInterface_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*QueryInterface)(IRecordInfo*,const IID*,void**);
     * }
     */
    public interface QueryInterface {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(QueryInterface fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.QueryInterface_UP$MH, fi, IRecordInfoVtbl.QueryInterface$FUNC, scope);
        }
        static QueryInterface ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.QueryInterface_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IRecordInfoVtbl.QueryInterface$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*QueryInterface)(IRecordInfo*,const IID*,void**);
     * }
     */
    public static MemorySegment QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.QueryInterface$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*QueryInterface)(IRecordInfo*,const IID*,void**);
     * }
     */
    public static void QueryInterface$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemorySegment QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface(MemorySegment segment, SegmentScope scope) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), scope);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor AddRef_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef_UP$MH = RuntimeHelper.upcallHandle(AddRef.class, "apply", IRecordInfoVtbl.AddRef_UP$FUNC);
    static final FunctionDescriptor AddRef_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.AddRef_DOWN$FUNC
    );
    /**
     * {@snippet :
 * ULONG (*AddRef)(IRecordInfo*);
     * }
     */
    public interface AddRef {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(AddRef fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.AddRef_UP$MH, fi, IRecordInfoVtbl.AddRef$FUNC, scope);
        }
        static AddRef ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IRecordInfoVtbl.AddRef_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IRecordInfoVtbl.AddRef$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ULONG (*AddRef)(IRecordInfo*);
     * }
     */
    public static MemorySegment AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.AddRef$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ULONG (*AddRef)(IRecordInfo*);
     * }
     */
    public static void AddRef$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.AddRef$VH.set(seg, x);
    }
    public static MemorySegment AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef(MemorySegment segment, SegmentScope scope) {
        return AddRef.ofAddress(AddRef$get(segment), scope);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor Release_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release_UP$MH = RuntimeHelper.upcallHandle(Release.class, "apply", IRecordInfoVtbl.Release_UP$FUNC);
    static final FunctionDescriptor Release_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.Release_DOWN$FUNC
    );
    /**
     * {@snippet :
 * ULONG (*Release)(IRecordInfo*);
     * }
     */
    public interface Release {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(Release fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.Release_UP$MH, fi, IRecordInfoVtbl.Release$FUNC, scope);
        }
        static Release ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IRecordInfoVtbl.Release_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IRecordInfoVtbl.Release$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ULONG (*Release)(IRecordInfo*);
     * }
     */
    public static MemorySegment Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.Release$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ULONG (*Release)(IRecordInfo*);
     * }
     */
    public static void Release$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.Release$VH.set(seg, x);
    }
    public static MemorySegment Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release(MemorySegment segment, SegmentScope scope) {
        return Release.ofAddress(Release$get(segment), scope);
    }
    static final FunctionDescriptor RecordInit$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor RecordInit_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordInit_UP$MH = RuntimeHelper.upcallHandle(RecordInit.class, "apply", IRecordInfoVtbl.RecordInit_UP$FUNC);
    static final FunctionDescriptor RecordInit_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordInit_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordInit_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*RecordInit)(IRecordInfo*,PVOID);
     * }
     */
    public interface RecordInit {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(RecordInit fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.RecordInit_UP$MH, fi, IRecordInfoVtbl.RecordInit$FUNC, scope);
        }
        static RecordInit ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordInit_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordInit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordInit"));
    public static VarHandle RecordInit$VH() {
        return IRecordInfoVtbl.RecordInit$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*RecordInit)(IRecordInfo*,PVOID);
     * }
     */
    public static MemorySegment RecordInit$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordInit$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*RecordInit)(IRecordInfo*,PVOID);
     * }
     */
    public static void RecordInit$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.RecordInit$VH.set(seg, x);
    }
    public static MemorySegment RecordInit$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordInit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordInit$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.RecordInit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordInit RecordInit(MemorySegment segment, SegmentScope scope) {
        return RecordInit.ofAddress(RecordInit$get(segment), scope);
    }
    static final FunctionDescriptor RecordClear$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor RecordClear_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordClear_UP$MH = RuntimeHelper.upcallHandle(RecordClear.class, "apply", IRecordInfoVtbl.RecordClear_UP$FUNC);
    static final FunctionDescriptor RecordClear_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordClear_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordClear_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*RecordClear)(IRecordInfo*,PVOID);
     * }
     */
    public interface RecordClear {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(RecordClear fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.RecordClear_UP$MH, fi, IRecordInfoVtbl.RecordClear$FUNC, scope);
        }
        static RecordClear ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordClear_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordClear$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordClear"));
    public static VarHandle RecordClear$VH() {
        return IRecordInfoVtbl.RecordClear$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*RecordClear)(IRecordInfo*,PVOID);
     * }
     */
    public static MemorySegment RecordClear$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordClear$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*RecordClear)(IRecordInfo*,PVOID);
     * }
     */
    public static void RecordClear$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.RecordClear$VH.set(seg, x);
    }
    public static MemorySegment RecordClear$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordClear$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordClear$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.RecordClear$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordClear RecordClear(MemorySegment segment, SegmentScope scope) {
        return RecordClear.ofAddress(RecordClear$get(segment), scope);
    }
    static final FunctionDescriptor RecordCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor RecordCopy_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCopy_UP$MH = RuntimeHelper.upcallHandle(RecordCopy.class, "apply", IRecordInfoVtbl.RecordCopy_UP$FUNC);
    static final FunctionDescriptor RecordCopy_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCopy_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordCopy_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*RecordCopy)(IRecordInfo*,PVOID,PVOID);
     * }
     */
    public interface RecordCopy {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(RecordCopy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.RecordCopy_UP$MH, fi, IRecordInfoVtbl.RecordCopy$FUNC, scope);
        }
        static RecordCopy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordCopy_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordCopy"));
    public static VarHandle RecordCopy$VH() {
        return IRecordInfoVtbl.RecordCopy$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*RecordCopy)(IRecordInfo*,PVOID,PVOID);
     * }
     */
    public static MemorySegment RecordCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCopy$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*RecordCopy)(IRecordInfo*,PVOID,PVOID);
     * }
     */
    public static void RecordCopy$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.RecordCopy$VH.set(seg, x);
    }
    public static MemorySegment RecordCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCopy$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.RecordCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCopy RecordCopy(MemorySegment segment, SegmentScope scope) {
        return RecordCopy.ofAddress(RecordCopy$get(segment), scope);
    }
    static final FunctionDescriptor GetGuid$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetGuid_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetGuid_UP$MH = RuntimeHelper.upcallHandle(GetGuid.class, "apply", IRecordInfoVtbl.GetGuid_UP$FUNC);
    static final FunctionDescriptor GetGuid_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetGuid_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetGuid_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetGuid)(IRecordInfo*,GUID*);
     * }
     */
    public interface GetGuid {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetGuid fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetGuid_UP$MH, fi, IRecordInfoVtbl.GetGuid$FUNC, scope);
        }
        static GetGuid ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetGuid_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetGuid$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetGuid"));
    public static VarHandle GetGuid$VH() {
        return IRecordInfoVtbl.GetGuid$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetGuid)(IRecordInfo*,GUID*);
     * }
     */
    public static MemorySegment GetGuid$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetGuid$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetGuid)(IRecordInfo*,GUID*);
     * }
     */
    public static void GetGuid$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetGuid$VH.set(seg, x);
    }
    public static MemorySegment GetGuid$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetGuid$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetGuid$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetGuid$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetGuid GetGuid(MemorySegment segment, SegmentScope scope) {
        return GetGuid.ofAddress(GetGuid$get(segment), scope);
    }
    static final FunctionDescriptor GetName$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetName_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetName_UP$MH = RuntimeHelper.upcallHandle(GetName.class, "apply", IRecordInfoVtbl.GetName_UP$FUNC);
    static final FunctionDescriptor GetName_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetName_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetName_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetName)(IRecordInfo*,BSTR*);
     * }
     */
    public interface GetName {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetName fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetName_UP$MH, fi, IRecordInfoVtbl.GetName$FUNC, scope);
        }
        static GetName ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetName_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetName$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetName"));
    public static VarHandle GetName$VH() {
        return IRecordInfoVtbl.GetName$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetName)(IRecordInfo*,BSTR*);
     * }
     */
    public static MemorySegment GetName$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetName$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetName)(IRecordInfo*,BSTR*);
     * }
     */
    public static void GetName$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetName$VH.set(seg, x);
    }
    public static MemorySegment GetName$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetName$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetName$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetName$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetName GetName(MemorySegment segment, SegmentScope scope) {
        return GetName.ofAddress(GetName$get(segment), scope);
    }
    static final FunctionDescriptor GetSize$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetSize_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSize_UP$MH = RuntimeHelper.upcallHandle(GetSize.class, "apply", IRecordInfoVtbl.GetSize_UP$FUNC);
    static final FunctionDescriptor GetSize_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSize_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetSize_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetSize)(IRecordInfo*,ULONG*);
     * }
     */
    public interface GetSize {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetSize fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetSize_UP$MH, fi, IRecordInfoVtbl.GetSize$FUNC, scope);
        }
        static GetSize ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetSize_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetSize"));
    public static VarHandle GetSize$VH() {
        return IRecordInfoVtbl.GetSize$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetSize)(IRecordInfo*,ULONG*);
     * }
     */
    public static MemorySegment GetSize$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetSize$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetSize)(IRecordInfo*,ULONG*);
     * }
     */
    public static void GetSize$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetSize$VH.set(seg, x);
    }
    public static MemorySegment GetSize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetSize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSize$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetSize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSize GetSize(MemorySegment segment, SegmentScope scope) {
        return GetSize.ofAddress(GetSize$get(segment), scope);
    }
    static final FunctionDescriptor GetTypeInfo$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetTypeInfo_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetTypeInfo_UP$MH = RuntimeHelper.upcallHandle(GetTypeInfo.class, "apply", IRecordInfoVtbl.GetTypeInfo_UP$FUNC);
    static final FunctionDescriptor GetTypeInfo_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetTypeInfo_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetTypeInfo_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetTypeInfo)(IRecordInfo*,ITypeInfo**);
     * }
     */
    public interface GetTypeInfo {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetTypeInfo fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetTypeInfo_UP$MH, fi, IRecordInfoVtbl.GetTypeInfo$FUNC, scope);
        }
        static GetTypeInfo ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.GetTypeInfo_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetTypeInfo$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetTypeInfo"));
    public static VarHandle GetTypeInfo$VH() {
        return IRecordInfoVtbl.GetTypeInfo$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetTypeInfo)(IRecordInfo*,ITypeInfo**);
     * }
     */
    public static MemorySegment GetTypeInfo$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetTypeInfo$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetTypeInfo)(IRecordInfo*,ITypeInfo**);
     * }
     */
    public static void GetTypeInfo$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetTypeInfo$VH.set(seg, x);
    }
    public static MemorySegment GetTypeInfo$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetTypeInfo$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetTypeInfo$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetTypeInfo$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetTypeInfo GetTypeInfo(MemorySegment segment, SegmentScope scope) {
        return GetTypeInfo.ofAddress(GetTypeInfo$get(segment), scope);
    }
    static final FunctionDescriptor GetField$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetField_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetField_UP$MH = RuntimeHelper.upcallHandle(GetField.class, "apply", IRecordInfoVtbl.GetField_UP$FUNC);
    static final FunctionDescriptor GetField_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetField_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetField_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetField)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public interface GetField {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(GetField fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetField_UP$MH, fi, IRecordInfoVtbl.GetField$FUNC, scope);
        }
        static GetField ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)IRecordInfoVtbl.GetField_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetField"));
    public static VarHandle GetField$VH() {
        return IRecordInfoVtbl.GetField$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetField)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public static MemorySegment GetField$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetField$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetField)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public static void GetField$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetField$VH.set(seg, x);
    }
    public static MemorySegment GetField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetField$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetField GetField(MemorySegment segment, SegmentScope scope) {
        return GetField.ofAddress(GetField$get(segment), scope);
    }
    static final FunctionDescriptor GetFieldNoCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetFieldNoCopy_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldNoCopy_UP$MH = RuntimeHelper.upcallHandle(GetFieldNoCopy.class, "apply", IRecordInfoVtbl.GetFieldNoCopy_UP$FUNC);
    static final FunctionDescriptor GetFieldNoCopy_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldNoCopy_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetFieldNoCopy_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetFieldNoCopy)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*,PVOID*);
     * }
     */
    public interface GetFieldNoCopy {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(GetFieldNoCopy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetFieldNoCopy_UP$MH, fi, IRecordInfoVtbl.GetFieldNoCopy$FUNC, scope);
        }
        static GetFieldNoCopy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)IRecordInfoVtbl.GetFieldNoCopy_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldNoCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFieldNoCopy"));
    public static VarHandle GetFieldNoCopy$VH() {
        return IRecordInfoVtbl.GetFieldNoCopy$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetFieldNoCopy)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*,PVOID*);
     * }
     */
    public static MemorySegment GetFieldNoCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetFieldNoCopy$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetFieldNoCopy)(IRecordInfo*,PVOID,LPCOLESTR,VARIANT*,PVOID*);
     * }
     */
    public static void GetFieldNoCopy$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetFieldNoCopy$VH.set(seg, x);
    }
    public static MemorySegment GetFieldNoCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetFieldNoCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldNoCopy$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetFieldNoCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldNoCopy GetFieldNoCopy(MemorySegment segment, SegmentScope scope) {
        return GetFieldNoCopy.ofAddress(GetFieldNoCopy$get(segment), scope);
    }
    static final FunctionDescriptor PutField$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor PutField_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PutField_UP$MH = RuntimeHelper.upcallHandle(PutField.class, "apply", IRecordInfoVtbl.PutField_UP$FUNC);
    static final FunctionDescriptor PutField_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PutField_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.PutField_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*PutField)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public interface PutField {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(PutField fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.PutField_UP$MH, fi, IRecordInfoVtbl.PutField$FUNC, scope);
        }
        static PutField ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)IRecordInfoVtbl.PutField_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PutField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("PutField"));
    public static VarHandle PutField$VH() {
        return IRecordInfoVtbl.PutField$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*PutField)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public static MemorySegment PutField$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.PutField$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*PutField)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public static void PutField$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.PutField$VH.set(seg, x);
    }
    public static MemorySegment PutField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.PutField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PutField$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.PutField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PutField PutField(MemorySegment segment, SegmentScope scope) {
        return PutField.ofAddress(PutField$get(segment), scope);
    }
    static final FunctionDescriptor PutFieldNoCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor PutFieldNoCopy_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PutFieldNoCopy_UP$MH = RuntimeHelper.upcallHandle(PutFieldNoCopy.class, "apply", IRecordInfoVtbl.PutFieldNoCopy_UP$FUNC);
    static final FunctionDescriptor PutFieldNoCopy_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PutFieldNoCopy_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.PutFieldNoCopy_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*PutFieldNoCopy)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public interface PutFieldNoCopy {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(PutFieldNoCopy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.PutFieldNoCopy_UP$MH, fi, IRecordInfoVtbl.PutFieldNoCopy$FUNC, scope);
        }
        static PutFieldNoCopy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)IRecordInfoVtbl.PutFieldNoCopy_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PutFieldNoCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("PutFieldNoCopy"));
    public static VarHandle PutFieldNoCopy$VH() {
        return IRecordInfoVtbl.PutFieldNoCopy$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*PutFieldNoCopy)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public static MemorySegment PutFieldNoCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.PutFieldNoCopy$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*PutFieldNoCopy)(IRecordInfo*,ULONG,PVOID,LPCOLESTR,VARIANT*);
     * }
     */
    public static void PutFieldNoCopy$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.PutFieldNoCopy$VH.set(seg, x);
    }
    public static MemorySegment PutFieldNoCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.PutFieldNoCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PutFieldNoCopy$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.PutFieldNoCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PutFieldNoCopy PutFieldNoCopy(MemorySegment segment, SegmentScope scope) {
        return PutFieldNoCopy.ofAddress(PutFieldNoCopy$get(segment), scope);
    }
    static final FunctionDescriptor GetFieldNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetFieldNames_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldNames_UP$MH = RuntimeHelper.upcallHandle(GetFieldNames.class, "apply", IRecordInfoVtbl.GetFieldNames_UP$FUNC);
    static final FunctionDescriptor GetFieldNames_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldNames_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.GetFieldNames_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetFieldNames)(IRecordInfo*,ULONG*,BSTR*);
     * }
     */
    public interface GetFieldNames {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(GetFieldNames fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.GetFieldNames_UP$MH, fi, IRecordInfoVtbl.GetFieldNames$FUNC, scope);
        }
        static GetFieldNames ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.GetFieldNames_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFieldNames"));
    public static VarHandle GetFieldNames$VH() {
        return IRecordInfoVtbl.GetFieldNames$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetFieldNames)(IRecordInfo*,ULONG*,BSTR*);
     * }
     */
    public static MemorySegment GetFieldNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetFieldNames$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetFieldNames)(IRecordInfo*,ULONG*,BSTR*);
     * }
     */
    public static void GetFieldNames$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.GetFieldNames$VH.set(seg, x);
    }
    public static MemorySegment GetFieldNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.GetFieldNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldNames$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.GetFieldNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldNames GetFieldNames(MemorySegment segment, SegmentScope scope) {
        return GetFieldNames.ofAddress(GetFieldNames$get(segment), scope);
    }
    static final FunctionDescriptor IsMatchingType$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor IsMatchingType_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsMatchingType_UP$MH = RuntimeHelper.upcallHandle(IsMatchingType.class, "apply", IRecordInfoVtbl.IsMatchingType_UP$FUNC);
    static final FunctionDescriptor IsMatchingType_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsMatchingType_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.IsMatchingType_DOWN$FUNC
    );
    /**
     * {@snippet :
 * BOOL (*IsMatchingType)(IRecordInfo*,IRecordInfo*);
     * }
     */
    public interface IsMatchingType {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(IsMatchingType fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.IsMatchingType_UP$MH, fi, IRecordInfoVtbl.IsMatchingType$FUNC, scope);
        }
        static IsMatchingType ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.IsMatchingType_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsMatchingType$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsMatchingType"));
    public static VarHandle IsMatchingType$VH() {
        return IRecordInfoVtbl.IsMatchingType$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * BOOL (*IsMatchingType)(IRecordInfo*,IRecordInfo*);
     * }
     */
    public static MemorySegment IsMatchingType$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.IsMatchingType$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * BOOL (*IsMatchingType)(IRecordInfo*,IRecordInfo*);
     * }
     */
    public static void IsMatchingType$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.IsMatchingType$VH.set(seg, x);
    }
    public static MemorySegment IsMatchingType$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.IsMatchingType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsMatchingType$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.IsMatchingType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsMatchingType IsMatchingType(MemorySegment segment, SegmentScope scope) {
        return IsMatchingType.ofAddress(IsMatchingType$get(segment), scope);
    }
    static final FunctionDescriptor RecordCreate$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor RecordCreate_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCreate_UP$MH = RuntimeHelper.upcallHandle(RecordCreate.class, "apply", IRecordInfoVtbl.RecordCreate_UP$FUNC);
    static final FunctionDescriptor RecordCreate_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCreate_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordCreate_DOWN$FUNC
    );
    /**
     * {@snippet :
 * PVOID (*RecordCreate)(IRecordInfo*);
     * }
     */
    public interface RecordCreate {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(RecordCreate fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.RecordCreate_UP$MH, fi, IRecordInfoVtbl.RecordCreate$FUNC, scope);
        }
        static RecordCreate ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCreate_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCreate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordCreate"));
    public static VarHandle RecordCreate$VH() {
        return IRecordInfoVtbl.RecordCreate$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * PVOID (*RecordCreate)(IRecordInfo*);
     * }
     */
    public static MemorySegment RecordCreate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCreate$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * PVOID (*RecordCreate)(IRecordInfo*);
     * }
     */
    public static void RecordCreate$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.RecordCreate$VH.set(seg, x);
    }
    public static MemorySegment RecordCreate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCreate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCreate$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.RecordCreate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCreate RecordCreate(MemorySegment segment, SegmentScope scope) {
        return RecordCreate.ofAddress(RecordCreate$get(segment), scope);
    }
    static final FunctionDescriptor RecordCreateCopy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor RecordCreateCopy_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCreateCopy_UP$MH = RuntimeHelper.upcallHandle(RecordCreateCopy.class, "apply", IRecordInfoVtbl.RecordCreateCopy_UP$FUNC);
    static final FunctionDescriptor RecordCreateCopy_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordCreateCopy_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordCreateCopy_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*RecordCreateCopy)(IRecordInfo*,PVOID,PVOID*);
     * }
     */
    public interface RecordCreateCopy {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(RecordCreateCopy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.RecordCreateCopy_UP$MH, fi, IRecordInfoVtbl.RecordCreateCopy$FUNC, scope);
        }
        static RecordCreateCopy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordCreateCopy_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordCreateCopy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordCreateCopy"));
    public static VarHandle RecordCreateCopy$VH() {
        return IRecordInfoVtbl.RecordCreateCopy$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*RecordCreateCopy)(IRecordInfo*,PVOID,PVOID*);
     * }
     */
    public static MemorySegment RecordCreateCopy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCreateCopy$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*RecordCreateCopy)(IRecordInfo*,PVOID,PVOID*);
     * }
     */
    public static void RecordCreateCopy$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.RecordCreateCopy$VH.set(seg, x);
    }
    public static MemorySegment RecordCreateCopy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordCreateCopy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordCreateCopy$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.RecordCreateCopy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordCreateCopy RecordCreateCopy(MemorySegment segment, SegmentScope scope) {
        return RecordCreateCopy.ofAddress(RecordCreateCopy$get(segment), scope);
    }
    static final FunctionDescriptor RecordDestroy$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor RecordDestroy_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordDestroy_UP$MH = RuntimeHelper.upcallHandle(RecordDestroy.class, "apply", IRecordInfoVtbl.RecordDestroy_UP$FUNC);
    static final FunctionDescriptor RecordDestroy_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RecordDestroy_DOWN$MH = RuntimeHelper.downcallHandle(
        IRecordInfoVtbl.RecordDestroy_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*RecordDestroy)(IRecordInfo*,PVOID);
     * }
     */
    public interface RecordDestroy {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(RecordDestroy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IRecordInfoVtbl.RecordDestroy_UP$MH, fi, IRecordInfoVtbl.RecordDestroy$FUNC, scope);
        }
        static RecordDestroy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IRecordInfoVtbl.RecordDestroy_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RecordDestroy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RecordDestroy"));
    public static VarHandle RecordDestroy$VH() {
        return IRecordInfoVtbl.RecordDestroy$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*RecordDestroy)(IRecordInfo*,PVOID);
     * }
     */
    public static MemorySegment RecordDestroy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordDestroy$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*RecordDestroy)(IRecordInfo*,PVOID);
     * }
     */
    public static void RecordDestroy$set(MemorySegment seg, MemorySegment x) {
        IRecordInfoVtbl.RecordDestroy$VH.set(seg, x);
    }
    public static MemorySegment RecordDestroy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IRecordInfoVtbl.RecordDestroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RecordDestroy$set(MemorySegment seg, long index, MemorySegment x) {
        IRecordInfoVtbl.RecordDestroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RecordDestroy RecordDestroy(MemorySegment segment, SegmentScope scope) {
        return RecordDestroy.ofAddress(RecordDestroy$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


