// Generated by jextract

package com.microsoft.win32;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct IOleObjectVtbl {
 *     HRESULT (*QueryInterface)(IOleObject*,const IID*,void**);
 *     ULONG (*AddRef)(IOleObject*);
 *     ULONG (*Release)(IOleObject*);
 *     HRESULT (*SetClientSite)(IOleObject*,IOleClientSite*);
 *     HRESULT (*GetClientSite)(IOleObject*,IOleClientSite**);
 *     HRESULT (*SetHostNames)(IOleObject*,LPCOLESTR,LPCOLESTR);
 *     HRESULT (*Close)(IOleObject*,DWORD);
 *     HRESULT (*SetMoniker)(IOleObject*,DWORD,IMoniker*);
 *     HRESULT (*GetMoniker)(IOleObject*,DWORD,DWORD,IMoniker**);
 *     HRESULT (*InitFromData)(IOleObject*,IDataObject*,BOOL,DWORD);
 *     HRESULT (*GetClipboardData)(IOleObject*,DWORD,IDataObject**);
 *     HRESULT (*DoVerb)(IOleObject*,LONG,LPMSG,IOleClientSite*,LONG,HWND,LPCRECT);
 *     HRESULT (*EnumVerbs)(IOleObject*,IEnumOLEVERB**);
 *     HRESULT (*Update)(IOleObject*);
 *     HRESULT (*IsUpToDate)(IOleObject*);
 *     HRESULT (*GetUserClassID)(IOleObject*,CLSID*);
 *     HRESULT (*GetUserType)(IOleObject*,DWORD,LPOLESTR*);
 *     HRESULT (*SetExtent)(IOleObject*,DWORD,SIZEL*);
 *     HRESULT (*GetExtent)(IOleObject*,DWORD,SIZEL*);
 *     HRESULT (*Advise)(IOleObject*,IAdviseSink*,DWORD*);
 *     HRESULT (*Unadvise)(IOleObject*,DWORD);
 *     HRESULT (*EnumAdvise)(IOleObject*,IEnumSTATDATA**);
 *     HRESULT (*GetMiscStatus)(IOleObject*,DWORD,DWORD*);
 *     HRESULT (*SetColorScheme)(IOleObject*,LOGPALETTE*);
 * };
 * }
 */
public class IOleObjectVtbl {

    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("SetClientSite"),
        Constants$root.C_POINTER$LAYOUT.withName("GetClientSite"),
        Constants$root.C_POINTER$LAYOUT.withName("SetHostNames"),
        Constants$root.C_POINTER$LAYOUT.withName("Close"),
        Constants$root.C_POINTER$LAYOUT.withName("SetMoniker"),
        Constants$root.C_POINTER$LAYOUT.withName("GetMoniker"),
        Constants$root.C_POINTER$LAYOUT.withName("InitFromData"),
        Constants$root.C_POINTER$LAYOUT.withName("GetClipboardData"),
        Constants$root.C_POINTER$LAYOUT.withName("DoVerb"),
        Constants$root.C_POINTER$LAYOUT.withName("EnumVerbs"),
        Constants$root.C_POINTER$LAYOUT.withName("Update"),
        Constants$root.C_POINTER$LAYOUT.withName("IsUpToDate"),
        Constants$root.C_POINTER$LAYOUT.withName("GetUserClassID"),
        Constants$root.C_POINTER$LAYOUT.withName("GetUserType"),
        Constants$root.C_POINTER$LAYOUT.withName("SetExtent"),
        Constants$root.C_POINTER$LAYOUT.withName("GetExtent"),
        Constants$root.C_POINTER$LAYOUT.withName("Advise"),
        Constants$root.C_POINTER$LAYOUT.withName("Unadvise"),
        Constants$root.C_POINTER$LAYOUT.withName("EnumAdvise"),
        Constants$root.C_POINTER$LAYOUT.withName("GetMiscStatus"),
        Constants$root.C_POINTER$LAYOUT.withName("SetColorScheme")
    ).withName("IOleObjectVtbl");
    public static MemoryLayout $LAYOUT() {
        return IOleObjectVtbl.$struct$LAYOUT;
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor QueryInterface_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface_UP$MH = RuntimeHelper.upcallHandle(QueryInterface.class, "apply", IOleObjectVtbl.QueryInterface_UP$FUNC);
    static final FunctionDescriptor QueryInterface_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.QueryInterface_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*QueryInterface)(IOleObject*,const IID*,void**);
     * }
     */
    public interface QueryInterface {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(QueryInterface fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.QueryInterface_UP$MH, fi, IOleObjectVtbl.QueryInterface$FUNC, scope);
        }
        static QueryInterface ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.QueryInterface_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IOleObjectVtbl.QueryInterface$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*QueryInterface)(IOleObject*,const IID*,void**);
     * }
     */
    public static MemorySegment QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.QueryInterface$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*QueryInterface)(IOleObject*,const IID*,void**);
     * }
     */
    public static void QueryInterface$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.QueryInterface$VH.set(seg, x);
    }
    public static MemorySegment QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface(MemorySegment segment, SegmentScope scope) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), scope);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor AddRef_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef_UP$MH = RuntimeHelper.upcallHandle(AddRef.class, "apply", IOleObjectVtbl.AddRef_UP$FUNC);
    static final FunctionDescriptor AddRef_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.AddRef_DOWN$FUNC
    );
    /**
     * {@snippet :
 * ULONG (*AddRef)(IOleObject*);
     * }
     */
    public interface AddRef {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(AddRef fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.AddRef_UP$MH, fi, IOleObjectVtbl.AddRef$FUNC, scope);
        }
        static AddRef ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleObjectVtbl.AddRef_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IOleObjectVtbl.AddRef$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ULONG (*AddRef)(IOleObject*);
     * }
     */
    public static MemorySegment AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.AddRef$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ULONG (*AddRef)(IOleObject*);
     * }
     */
    public static void AddRef$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.AddRef$VH.set(seg, x);
    }
    public static MemorySegment AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef(MemorySegment segment, SegmentScope scope) {
        return AddRef.ofAddress(AddRef$get(segment), scope);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor Release_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release_UP$MH = RuntimeHelper.upcallHandle(Release.class, "apply", IOleObjectVtbl.Release_UP$FUNC);
    static final FunctionDescriptor Release_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Release_DOWN$FUNC
    );
    /**
     * {@snippet :
 * ULONG (*Release)(IOleObject*);
     * }
     */
    public interface Release {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(Release fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.Release_UP$MH, fi, IOleObjectVtbl.Release$FUNC, scope);
        }
        static Release ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleObjectVtbl.Release_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IOleObjectVtbl.Release$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ULONG (*Release)(IOleObject*);
     * }
     */
    public static MemorySegment Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Release$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ULONG (*Release)(IOleObject*);
     * }
     */
    public static void Release$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.Release$VH.set(seg, x);
    }
    public static MemorySegment Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release(MemorySegment segment, SegmentScope scope) {
        return Release.ofAddress(Release$get(segment), scope);
    }
    static final FunctionDescriptor SetClientSite$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetClientSite_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetClientSite_UP$MH = RuntimeHelper.upcallHandle(SetClientSite.class, "apply", IOleObjectVtbl.SetClientSite_UP$FUNC);
    static final FunctionDescriptor SetClientSite_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetClientSite_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetClientSite_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetClientSite)(IOleObject*,IOleClientSite*);
     * }
     */
    public interface SetClientSite {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(SetClientSite fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.SetClientSite_UP$MH, fi, IOleObjectVtbl.SetClientSite$FUNC, scope);
        }
        static SetClientSite ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleObjectVtbl.SetClientSite_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetClientSite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetClientSite"));
    public static VarHandle SetClientSite$VH() {
        return IOleObjectVtbl.SetClientSite$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetClientSite)(IOleObject*,IOleClientSite*);
     * }
     */
    public static MemorySegment SetClientSite$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetClientSite$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetClientSite)(IOleObject*,IOleClientSite*);
     * }
     */
    public static void SetClientSite$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.SetClientSite$VH.set(seg, x);
    }
    public static MemorySegment SetClientSite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetClientSite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetClientSite$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.SetClientSite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetClientSite SetClientSite(MemorySegment segment, SegmentScope scope) {
        return SetClientSite.ofAddress(SetClientSite$get(segment), scope);
    }
    static final FunctionDescriptor GetClientSite$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetClientSite_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetClientSite_UP$MH = RuntimeHelper.upcallHandle(GetClientSite.class, "apply", IOleObjectVtbl.GetClientSite_UP$FUNC);
    static final FunctionDescriptor GetClientSite_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetClientSite_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetClientSite_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetClientSite)(IOleObject*,IOleClientSite**);
     * }
     */
    public interface GetClientSite {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetClientSite fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetClientSite_UP$MH, fi, IOleObjectVtbl.GetClientSite$FUNC, scope);
        }
        static GetClientSite ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleObjectVtbl.GetClientSite_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetClientSite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetClientSite"));
    public static VarHandle GetClientSite$VH() {
        return IOleObjectVtbl.GetClientSite$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetClientSite)(IOleObject*,IOleClientSite**);
     * }
     */
    public static MemorySegment GetClientSite$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetClientSite$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetClientSite)(IOleObject*,IOleClientSite**);
     * }
     */
    public static void GetClientSite$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetClientSite$VH.set(seg, x);
    }
    public static MemorySegment GetClientSite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetClientSite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetClientSite$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetClientSite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetClientSite GetClientSite(MemorySegment segment, SegmentScope scope) {
        return GetClientSite.ofAddress(GetClientSite$get(segment), scope);
    }
    static final FunctionDescriptor SetHostNames$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetHostNames_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetHostNames_UP$MH = RuntimeHelper.upcallHandle(SetHostNames.class, "apply", IOleObjectVtbl.SetHostNames_UP$FUNC);
    static final FunctionDescriptor SetHostNames_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetHostNames_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetHostNames_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetHostNames)(IOleObject*,LPCOLESTR,LPCOLESTR);
     * }
     */
    public interface SetHostNames {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(SetHostNames fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.SetHostNames_UP$MH, fi, IOleObjectVtbl.SetHostNames$FUNC, scope);
        }
        static SetHostNames ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetHostNames_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetHostNames$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetHostNames"));
    public static VarHandle SetHostNames$VH() {
        return IOleObjectVtbl.SetHostNames$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetHostNames)(IOleObject*,LPCOLESTR,LPCOLESTR);
     * }
     */
    public static MemorySegment SetHostNames$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetHostNames$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetHostNames)(IOleObject*,LPCOLESTR,LPCOLESTR);
     * }
     */
    public static void SetHostNames$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.SetHostNames$VH.set(seg, x);
    }
    public static MemorySegment SetHostNames$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetHostNames$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetHostNames$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.SetHostNames$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetHostNames SetHostNames(MemorySegment segment, SegmentScope scope) {
        return SetHostNames.ofAddress(SetHostNames$get(segment), scope);
    }
    static final FunctionDescriptor Close$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final FunctionDescriptor Close_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Close_UP$MH = RuntimeHelper.upcallHandle(Close.class, "apply", IOleObjectVtbl.Close_UP$FUNC);
    static final FunctionDescriptor Close_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Close_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Close_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*Close)(IOleObject*,DWORD);
     * }
     */
    public interface Close {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(Close fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.Close_UP$MH, fi, IOleObjectVtbl.Close$FUNC, scope);
        }
        static Close ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)IOleObjectVtbl.Close_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Close$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Close"));
    public static VarHandle Close$VH() {
        return IOleObjectVtbl.Close$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*Close)(IOleObject*,DWORD);
     * }
     */
    public static MemorySegment Close$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Close$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*Close)(IOleObject*,DWORD);
     * }
     */
    public static void Close$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.Close$VH.set(seg, x);
    }
    public static MemorySegment Close$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Close$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Close$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.Close$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Close Close(MemorySegment segment, SegmentScope scope) {
        return Close.ofAddress(Close$get(segment), scope);
    }
    static final FunctionDescriptor SetMoniker$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetMoniker_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetMoniker_UP$MH = RuntimeHelper.upcallHandle(SetMoniker.class, "apply", IOleObjectVtbl.SetMoniker_UP$FUNC);
    static final FunctionDescriptor SetMoniker_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetMoniker_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetMoniker_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetMoniker)(IOleObject*,DWORD,IMoniker*);
     * }
     */
    public interface SetMoniker {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(SetMoniker fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.SetMoniker_UP$MH, fi, IOleObjectVtbl.SetMoniker$FUNC, scope);
        }
        static SetMoniker ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetMoniker_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetMoniker$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetMoniker"));
    public static VarHandle SetMoniker$VH() {
        return IOleObjectVtbl.SetMoniker$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetMoniker)(IOleObject*,DWORD,IMoniker*);
     * }
     */
    public static MemorySegment SetMoniker$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetMoniker$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetMoniker)(IOleObject*,DWORD,IMoniker*);
     * }
     */
    public static void SetMoniker$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.SetMoniker$VH.set(seg, x);
    }
    public static MemorySegment SetMoniker$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetMoniker$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.SetMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetMoniker SetMoniker(MemorySegment segment, SegmentScope scope) {
        return SetMoniker.ofAddress(SetMoniker$get(segment), scope);
    }
    static final FunctionDescriptor GetMoniker$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetMoniker_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMoniker_UP$MH = RuntimeHelper.upcallHandle(GetMoniker.class, "apply", IOleObjectVtbl.GetMoniker_UP$FUNC);
    static final FunctionDescriptor GetMoniker_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMoniker_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetMoniker_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetMoniker)(IOleObject*,DWORD,DWORD,IMoniker**);
     * }
     */
    public interface GetMoniker {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(GetMoniker fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetMoniker_UP$MH, fi, IOleObjectVtbl.GetMoniker$FUNC, scope);
        }
        static GetMoniker ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)IOleObjectVtbl.GetMoniker_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMoniker$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetMoniker"));
    public static VarHandle GetMoniker$VH() {
        return IOleObjectVtbl.GetMoniker$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetMoniker)(IOleObject*,DWORD,DWORD,IMoniker**);
     * }
     */
    public static MemorySegment GetMoniker$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetMoniker$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetMoniker)(IOleObject*,DWORD,DWORD,IMoniker**);
     * }
     */
    public static void GetMoniker$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetMoniker$VH.set(seg, x);
    }
    public static MemorySegment GetMoniker$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetMoniker$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMoniker$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetMoniker$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMoniker GetMoniker(MemorySegment segment, SegmentScope scope) {
        return GetMoniker.ofAddress(GetMoniker$get(segment), scope);
    }
    static final FunctionDescriptor InitFromData$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final FunctionDescriptor InitFromData_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle InitFromData_UP$MH = RuntimeHelper.upcallHandle(InitFromData.class, "apply", IOleObjectVtbl.InitFromData_UP$FUNC);
    static final FunctionDescriptor InitFromData_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle InitFromData_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.InitFromData_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*InitFromData)(IOleObject*,IDataObject*,BOOL,DWORD);
     * }
     */
    public interface InitFromData {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2, int _x3);
        static MemorySegment allocate(InitFromData fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.InitFromData_UP$MH, fi, IOleObjectVtbl.InitFromData$FUNC, scope);
        }
        static InitFromData ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2, int __x3) -> {
                try {
                    return (int)IOleObjectVtbl.InitFromData_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle InitFromData$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("InitFromData"));
    public static VarHandle InitFromData$VH() {
        return IOleObjectVtbl.InitFromData$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*InitFromData)(IOleObject*,IDataObject*,BOOL,DWORD);
     * }
     */
    public static MemorySegment InitFromData$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.InitFromData$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*InitFromData)(IOleObject*,IDataObject*,BOOL,DWORD);
     * }
     */
    public static void InitFromData$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.InitFromData$VH.set(seg, x);
    }
    public static MemorySegment InitFromData$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.InitFromData$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void InitFromData$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.InitFromData$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static InitFromData InitFromData(MemorySegment segment, SegmentScope scope) {
        return InitFromData.ofAddress(InitFromData$get(segment), scope);
    }
    static final FunctionDescriptor GetClipboardData$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetClipboardData_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetClipboardData_UP$MH = RuntimeHelper.upcallHandle(GetClipboardData.class, "apply", IOleObjectVtbl.GetClipboardData_UP$FUNC);
    static final FunctionDescriptor GetClipboardData_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetClipboardData_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetClipboardData_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetClipboardData)(IOleObject*,DWORD,IDataObject**);
     * }
     */
    public interface GetClipboardData {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(GetClipboardData fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetClipboardData_UP$MH, fi, IOleObjectVtbl.GetClipboardData$FUNC, scope);
        }
        static GetClipboardData ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetClipboardData_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetClipboardData$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetClipboardData"));
    public static VarHandle GetClipboardData$VH() {
        return IOleObjectVtbl.GetClipboardData$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetClipboardData)(IOleObject*,DWORD,IDataObject**);
     * }
     */
    public static MemorySegment GetClipboardData$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetClipboardData$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetClipboardData)(IOleObject*,DWORD,IDataObject**);
     * }
     */
    public static void GetClipboardData$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetClipboardData$VH.set(seg, x);
    }
    public static MemorySegment GetClipboardData$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetClipboardData$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetClipboardData$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetClipboardData$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetClipboardData GetClipboardData(MemorySegment segment, SegmentScope scope) {
        return GetClipboardData.ofAddress(GetClipboardData$get(segment), scope);
    }
    static final FunctionDescriptor DoVerb$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor DoVerb_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DoVerb_UP$MH = RuntimeHelper.upcallHandle(DoVerb.class, "apply", IOleObjectVtbl.DoVerb_UP$FUNC);
    static final FunctionDescriptor DoVerb_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DoVerb_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.DoVerb_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*DoVerb)(IOleObject*,LONG,LPMSG,IOleClientSite*,LONG,HWND,LPCRECT);
     * }
     */
    public interface DoVerb {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, int _x4, java.lang.foreign.MemorySegment _x5, java.lang.foreign.MemorySegment _x6);
        static MemorySegment allocate(DoVerb fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.DoVerb_UP$MH, fi, IOleObjectVtbl.DoVerb$FUNC, scope);
        }
        static DoVerb ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, int __x4, java.lang.foreign.MemorySegment __x5, java.lang.foreign.MemorySegment __x6) -> {
                try {
                    return (int)IOleObjectVtbl.DoVerb_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5, __x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DoVerb$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DoVerb"));
    public static VarHandle DoVerb$VH() {
        return IOleObjectVtbl.DoVerb$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*DoVerb)(IOleObject*,LONG,LPMSG,IOleClientSite*,LONG,HWND,LPCRECT);
     * }
     */
    public static MemorySegment DoVerb$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.DoVerb$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*DoVerb)(IOleObject*,LONG,LPMSG,IOleClientSite*,LONG,HWND,LPCRECT);
     * }
     */
    public static void DoVerb$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.DoVerb$VH.set(seg, x);
    }
    public static MemorySegment DoVerb$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.DoVerb$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DoVerb$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.DoVerb$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DoVerb DoVerb(MemorySegment segment, SegmentScope scope) {
        return DoVerb.ofAddress(DoVerb$get(segment), scope);
    }
    static final FunctionDescriptor EnumVerbs$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor EnumVerbs_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle EnumVerbs_UP$MH = RuntimeHelper.upcallHandle(EnumVerbs.class, "apply", IOleObjectVtbl.EnumVerbs_UP$FUNC);
    static final FunctionDescriptor EnumVerbs_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle EnumVerbs_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.EnumVerbs_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*EnumVerbs)(IOleObject*,IEnumOLEVERB**);
     * }
     */
    public interface EnumVerbs {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(EnumVerbs fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.EnumVerbs_UP$MH, fi, IOleObjectVtbl.EnumVerbs$FUNC, scope);
        }
        static EnumVerbs ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleObjectVtbl.EnumVerbs_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnumVerbs$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("EnumVerbs"));
    public static VarHandle EnumVerbs$VH() {
        return IOleObjectVtbl.EnumVerbs$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*EnumVerbs)(IOleObject*,IEnumOLEVERB**);
     * }
     */
    public static MemorySegment EnumVerbs$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.EnumVerbs$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*EnumVerbs)(IOleObject*,IEnumOLEVERB**);
     * }
     */
    public static void EnumVerbs$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.EnumVerbs$VH.set(seg, x);
    }
    public static MemorySegment EnumVerbs$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.EnumVerbs$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnumVerbs$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.EnumVerbs$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnumVerbs EnumVerbs(MemorySegment segment, SegmentScope scope) {
        return EnumVerbs.ofAddress(EnumVerbs$get(segment), scope);
    }
    static final FunctionDescriptor Update$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor Update_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Update_UP$MH = RuntimeHelper.upcallHandle(Update.class, "apply", IOleObjectVtbl.Update_UP$FUNC);
    static final FunctionDescriptor Update_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Update_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Update_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*Update)(IOleObject*);
     * }
     */
    public interface Update {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(Update fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.Update_UP$MH, fi, IOleObjectVtbl.Update$FUNC, scope);
        }
        static Update ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleObjectVtbl.Update_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Update$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Update"));
    public static VarHandle Update$VH() {
        return IOleObjectVtbl.Update$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*Update)(IOleObject*);
     * }
     */
    public static MemorySegment Update$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Update$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*Update)(IOleObject*);
     * }
     */
    public static void Update$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.Update$VH.set(seg, x);
    }
    public static MemorySegment Update$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Update$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Update$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.Update$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Update Update(MemorySegment segment, SegmentScope scope) {
        return Update.ofAddress(Update$get(segment), scope);
    }
    static final FunctionDescriptor IsUpToDate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor IsUpToDate_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsUpToDate_UP$MH = RuntimeHelper.upcallHandle(IsUpToDate.class, "apply", IOleObjectVtbl.IsUpToDate_UP$FUNC);
    static final FunctionDescriptor IsUpToDate_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsUpToDate_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.IsUpToDate_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*IsUpToDate)(IOleObject*);
     * }
     */
    public interface IsUpToDate {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(IsUpToDate fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.IsUpToDate_UP$MH, fi, IOleObjectVtbl.IsUpToDate$FUNC, scope);
        }
        static IsUpToDate ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)IOleObjectVtbl.IsUpToDate_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsUpToDate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsUpToDate"));
    public static VarHandle IsUpToDate$VH() {
        return IOleObjectVtbl.IsUpToDate$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*IsUpToDate)(IOleObject*);
     * }
     */
    public static MemorySegment IsUpToDate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.IsUpToDate$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*IsUpToDate)(IOleObject*);
     * }
     */
    public static void IsUpToDate$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.IsUpToDate$VH.set(seg, x);
    }
    public static MemorySegment IsUpToDate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.IsUpToDate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsUpToDate$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.IsUpToDate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsUpToDate IsUpToDate(MemorySegment segment, SegmentScope scope) {
        return IsUpToDate.ofAddress(IsUpToDate$get(segment), scope);
    }
    static final FunctionDescriptor GetUserClassID$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetUserClassID_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserClassID_UP$MH = RuntimeHelper.upcallHandle(GetUserClassID.class, "apply", IOleObjectVtbl.GetUserClassID_UP$FUNC);
    static final FunctionDescriptor GetUserClassID_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserClassID_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetUserClassID_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetUserClassID)(IOleObject*,CLSID*);
     * }
     */
    public interface GetUserClassID {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(GetUserClassID fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetUserClassID_UP$MH, fi, IOleObjectVtbl.GetUserClassID$FUNC, scope);
        }
        static GetUserClassID ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleObjectVtbl.GetUserClassID_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserClassID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetUserClassID"));
    public static VarHandle GetUserClassID$VH() {
        return IOleObjectVtbl.GetUserClassID$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetUserClassID)(IOleObject*,CLSID*);
     * }
     */
    public static MemorySegment GetUserClassID$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetUserClassID$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetUserClassID)(IOleObject*,CLSID*);
     * }
     */
    public static void GetUserClassID$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetUserClassID$VH.set(seg, x);
    }
    public static MemorySegment GetUserClassID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetUserClassID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserClassID$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetUserClassID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserClassID GetUserClassID(MemorySegment segment, SegmentScope scope) {
        return GetUserClassID.ofAddress(GetUserClassID$get(segment), scope);
    }
    static final FunctionDescriptor GetUserType$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetUserType_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserType_UP$MH = RuntimeHelper.upcallHandle(GetUserType.class, "apply", IOleObjectVtbl.GetUserType_UP$FUNC);
    static final FunctionDescriptor GetUserType_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetUserType_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetUserType_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetUserType)(IOleObject*,DWORD,LPOLESTR*);
     * }
     */
    public interface GetUserType {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(GetUserType fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetUserType_UP$MH, fi, IOleObjectVtbl.GetUserType$FUNC, scope);
        }
        static GetUserType ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetUserType_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetUserType$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetUserType"));
    public static VarHandle GetUserType$VH() {
        return IOleObjectVtbl.GetUserType$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetUserType)(IOleObject*,DWORD,LPOLESTR*);
     * }
     */
    public static MemorySegment GetUserType$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetUserType$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetUserType)(IOleObject*,DWORD,LPOLESTR*);
     * }
     */
    public static void GetUserType$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetUserType$VH.set(seg, x);
    }
    public static MemorySegment GetUserType$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetUserType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetUserType$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetUserType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetUserType GetUserType(MemorySegment segment, SegmentScope scope) {
        return GetUserType.ofAddress(GetUserType$get(segment), scope);
    }
    static final FunctionDescriptor SetExtent$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetExtent_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetExtent_UP$MH = RuntimeHelper.upcallHandle(SetExtent.class, "apply", IOleObjectVtbl.SetExtent_UP$FUNC);
    static final FunctionDescriptor SetExtent_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetExtent_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetExtent_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetExtent)(IOleObject*,DWORD,SIZEL*);
     * }
     */
    public interface SetExtent {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(SetExtent fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.SetExtent_UP$MH, fi, IOleObjectVtbl.SetExtent$FUNC, scope);
        }
        static SetExtent ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.SetExtent_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetExtent$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetExtent"));
    public static VarHandle SetExtent$VH() {
        return IOleObjectVtbl.SetExtent$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetExtent)(IOleObject*,DWORD,SIZEL*);
     * }
     */
    public static MemorySegment SetExtent$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetExtent$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetExtent)(IOleObject*,DWORD,SIZEL*);
     * }
     */
    public static void SetExtent$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.SetExtent$VH.set(seg, x);
    }
    public static MemorySegment SetExtent$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetExtent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetExtent$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.SetExtent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetExtent SetExtent(MemorySegment segment, SegmentScope scope) {
        return SetExtent.ofAddress(SetExtent$get(segment), scope);
    }
    static final FunctionDescriptor GetExtent$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetExtent_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetExtent_UP$MH = RuntimeHelper.upcallHandle(GetExtent.class, "apply", IOleObjectVtbl.GetExtent_UP$FUNC);
    static final FunctionDescriptor GetExtent_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetExtent_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetExtent_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetExtent)(IOleObject*,DWORD,SIZEL*);
     * }
     */
    public interface GetExtent {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(GetExtent fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetExtent_UP$MH, fi, IOleObjectVtbl.GetExtent$FUNC, scope);
        }
        static GetExtent ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetExtent_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetExtent$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetExtent"));
    public static VarHandle GetExtent$VH() {
        return IOleObjectVtbl.GetExtent$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetExtent)(IOleObject*,DWORD,SIZEL*);
     * }
     */
    public static MemorySegment GetExtent$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetExtent$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetExtent)(IOleObject*,DWORD,SIZEL*);
     * }
     */
    public static void GetExtent$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetExtent$VH.set(seg, x);
    }
    public static MemorySegment GetExtent$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetExtent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetExtent$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetExtent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetExtent GetExtent(MemorySegment segment, SegmentScope scope) {
        return GetExtent.ofAddress(GetExtent$get(segment), scope);
    }
    static final FunctionDescriptor Advise$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor Advise_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Advise_UP$MH = RuntimeHelper.upcallHandle(Advise.class, "apply", IOleObjectVtbl.Advise_UP$FUNC);
    static final FunctionDescriptor Advise_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Advise_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Advise_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*Advise)(IOleObject*,IAdviseSink*,DWORD*);
     * }
     */
    public interface Advise {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(Advise fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.Advise_UP$MH, fi, IOleObjectVtbl.Advise$FUNC, scope);
        }
        static Advise ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.Advise_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Advise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Advise"));
    public static VarHandle Advise$VH() {
        return IOleObjectVtbl.Advise$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*Advise)(IOleObject*,IAdviseSink*,DWORD*);
     * }
     */
    public static MemorySegment Advise$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Advise$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*Advise)(IOleObject*,IAdviseSink*,DWORD*);
     * }
     */
    public static void Advise$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.Advise$VH.set(seg, x);
    }
    public static MemorySegment Advise$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Advise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Advise$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.Advise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Advise Advise(MemorySegment segment, SegmentScope scope) {
        return Advise.ofAddress(Advise$get(segment), scope);
    }
    static final FunctionDescriptor Unadvise$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final FunctionDescriptor Unadvise_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Unadvise_UP$MH = RuntimeHelper.upcallHandle(Unadvise.class, "apply", IOleObjectVtbl.Unadvise_UP$FUNC);
    static final FunctionDescriptor Unadvise_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle Unadvise_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.Unadvise_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*Unadvise)(IOleObject*,DWORD);
     * }
     */
    public interface Unadvise {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(Unadvise fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.Unadvise_UP$MH, fi, IOleObjectVtbl.Unadvise$FUNC, scope);
        }
        static Unadvise ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)IOleObjectVtbl.Unadvise_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Unadvise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Unadvise"));
    public static VarHandle Unadvise$VH() {
        return IOleObjectVtbl.Unadvise$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*Unadvise)(IOleObject*,DWORD);
     * }
     */
    public static MemorySegment Unadvise$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Unadvise$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*Unadvise)(IOleObject*,DWORD);
     * }
     */
    public static void Unadvise$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.Unadvise$VH.set(seg, x);
    }
    public static MemorySegment Unadvise$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.Unadvise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Unadvise$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.Unadvise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Unadvise Unadvise(MemorySegment segment, SegmentScope scope) {
        return Unadvise.ofAddress(Unadvise$get(segment), scope);
    }
    static final FunctionDescriptor EnumAdvise$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor EnumAdvise_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle EnumAdvise_UP$MH = RuntimeHelper.upcallHandle(EnumAdvise.class, "apply", IOleObjectVtbl.EnumAdvise_UP$FUNC);
    static final FunctionDescriptor EnumAdvise_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle EnumAdvise_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.EnumAdvise_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*EnumAdvise)(IOleObject*,IEnumSTATDATA**);
     * }
     */
    public interface EnumAdvise {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(EnumAdvise fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.EnumAdvise_UP$MH, fi, IOleObjectVtbl.EnumAdvise$FUNC, scope);
        }
        static EnumAdvise ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleObjectVtbl.EnumAdvise_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnumAdvise$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("EnumAdvise"));
    public static VarHandle EnumAdvise$VH() {
        return IOleObjectVtbl.EnumAdvise$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*EnumAdvise)(IOleObject*,IEnumSTATDATA**);
     * }
     */
    public static MemorySegment EnumAdvise$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.EnumAdvise$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*EnumAdvise)(IOleObject*,IEnumSTATDATA**);
     * }
     */
    public static void EnumAdvise$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.EnumAdvise$VH.set(seg, x);
    }
    public static MemorySegment EnumAdvise$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.EnumAdvise$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnumAdvise$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.EnumAdvise$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnumAdvise EnumAdvise(MemorySegment segment, SegmentScope scope) {
        return EnumAdvise.ofAddress(EnumAdvise$get(segment), scope);
    }
    static final FunctionDescriptor GetMiscStatus$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor GetMiscStatus_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMiscStatus_UP$MH = RuntimeHelper.upcallHandle(GetMiscStatus.class, "apply", IOleObjectVtbl.GetMiscStatus_UP$FUNC);
    static final FunctionDescriptor GetMiscStatus_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMiscStatus_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.GetMiscStatus_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*GetMiscStatus)(IOleObject*,DWORD,DWORD*);
     * }
     */
    public interface GetMiscStatus {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(GetMiscStatus fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.GetMiscStatus_UP$MH, fi, IOleObjectVtbl.GetMiscStatus$FUNC, scope);
        }
        static GetMiscStatus ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)IOleObjectVtbl.GetMiscStatus_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMiscStatus$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetMiscStatus"));
    public static VarHandle GetMiscStatus$VH() {
        return IOleObjectVtbl.GetMiscStatus$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*GetMiscStatus)(IOleObject*,DWORD,DWORD*);
     * }
     */
    public static MemorySegment GetMiscStatus$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetMiscStatus$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*GetMiscStatus)(IOleObject*,DWORD,DWORD*);
     * }
     */
    public static void GetMiscStatus$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.GetMiscStatus$VH.set(seg, x);
    }
    public static MemorySegment GetMiscStatus$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.GetMiscStatus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMiscStatus$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.GetMiscStatus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMiscStatus GetMiscStatus(MemorySegment segment, SegmentScope scope) {
        return GetMiscStatus.ofAddress(GetMiscStatus$get(segment), scope);
    }
    static final FunctionDescriptor SetColorScheme$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor SetColorScheme_UP$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetColorScheme_UP$MH = RuntimeHelper.upcallHandle(SetColorScheme.class, "apply", IOleObjectVtbl.SetColorScheme_UP$FUNC);
    static final FunctionDescriptor SetColorScheme_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetColorScheme_DOWN$MH = RuntimeHelper.downcallHandle(
        IOleObjectVtbl.SetColorScheme_DOWN$FUNC
    );
    /**
     * {@snippet :
 * HRESULT (*SetColorScheme)(IOleObject*,LOGPALETTE*);
     * }
     */
    public interface SetColorScheme {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(SetColorScheme fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(IOleObjectVtbl.SetColorScheme_UP$MH, fi, IOleObjectVtbl.SetColorScheme$FUNC, scope);
        }
        static SetColorScheme ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)IOleObjectVtbl.SetColorScheme_DOWN$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetColorScheme$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetColorScheme"));
    public static VarHandle SetColorScheme$VH() {
        return IOleObjectVtbl.SetColorScheme$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * HRESULT (*SetColorScheme)(IOleObject*,LOGPALETTE*);
     * }
     */
    public static MemorySegment SetColorScheme$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetColorScheme$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * HRESULT (*SetColorScheme)(IOleObject*,LOGPALETTE*);
     * }
     */
    public static void SetColorScheme$set(MemorySegment seg, MemorySegment x) {
        IOleObjectVtbl.SetColorScheme$VH.set(seg, x);
    }
    public static MemorySegment SetColorScheme$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)IOleObjectVtbl.SetColorScheme$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetColorScheme$set(MemorySegment seg, long index, MemorySegment x) {
        IOleObjectVtbl.SetColorScheme$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetColorScheme SetColorScheme(MemorySegment segment, SegmentScope scope) {
        return SetColorScheme.ofAddress(SetColorScheme$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


